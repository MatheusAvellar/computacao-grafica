# -*- coding: utf-8 -*-
"""Prática 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16nx8l_qc6wb2X34vlMiYLYt-a-vqMIPA

# Prática 2

Pela dupla maravilhosa:

1.   **Matheus Avellar de Barros** (DRE 117038497)
2.   **Pedro Novaes Possato** (DRE 117053803)
"""

import numpy as np
import scipy as sp
import cv2
from google.colab.patches import cv2_imshow
from google.colab import files
from matplotlib import patheffects
import matplotlib.pyplot as plt
import json
from google.colab import files

"""## Image upload"""

uploaded = files.upload()
for fn in uploaded.keys():
  graphicx_data = (cv2.cvtColor(cv2.imread(fn), cv2.COLOR_BGR2GRAY)).astype(float)
  print('User uploaded file "{name}" with length {length} bytes'.format(name=fn, length=len(uploaded[fn])))

"""## JSON upload"""

uploaded = files.upload()
for fn in uploaded.keys():
  f = open(fn, )
  graphicx_mod = json.load(f)
  print('User uploaded file "{name}" with length {length} bytes'.format(name=fn, length=len(uploaded[fn])))

"""# Code (inside test and Screen class)"""

class ImageProcesser:
  ''' 
    Apply kernel and affine xform to raster images.

    Args:
        img (np.array): grayscale image in matrix form
        gmod (dict): dictionary containing kernel and affine xform information
  '''
  def __init__(self, img, gmod):
    self._image = np.copy(img)
    self._width = img.shape[0]
    self._height = img.shape[1]
    self._kernel = gmod.get("kernel")
    self._bhandler = gmod.get("bhandler")
    self._xform = gmod.get("xform")

  def apply_kernel(self, border):
    '''
    Method to apply kernel over image
    
    border: 'icrop' is for cropping image borders, 'extend' is for extending image border
    
    You may create auxiliary functions/methods if you'd like
    '''
    # Decidimos transformar todos os BHandlers em 'icrop'. Assim, para os que
    # são 'extend', criamos uma borda estendida para ser cropada depois; para os
    # que são 'icrop', a imagem é cropada normalmente sem modificações prévias
    if self._bhandler == "extend":
      width = self._width + 2
      height = self._height + 2
      ext_image = np.zeros((width, height))
      for x in range(width):
        for y in range(height):
          top = (y == 0)
          bottom = (y == height-1)
          left = (x == 0)
          right = (x == width-1)
          # Caso o pixel não esteja nas bordas, copiamos o pixel da imagem
          # original
          if not top and not left and not bottom and not right:
            ext_image[x][y] = self._image[x-1][y-1]
          # Caso contrário, precisamos estender a borda correspondente
          else:
            # Péssimo que Python não tenha switch
            if top:
              if left:
                ext_image[x][y] = self._image[0][0]
              elif right:
                ext_image[x][y] = self._image[self._width-1][0]
              else:
                ext_image[x][y] = self._image[x-1][0]
            elif bottom:
              if left:
                ext_image[x][y] = self._image[0][self._height-1]
              elif right:
                ext_image[x][y] = self._image[self._width-1][self._height-1]
              else:
                ext_image[x][y] = self._image[x-1][self._height-1]
            elif left:
              ext_image[x][y] = self._image[0][y-1]
            else:#right
              ext_image[x][y] = self._image[self._width-1][y-1]
      # Atualiza a imagem com borda gerada, e seu novo tamanho
      self._image = ext_image
      self._width = width
      self._height = height
  
    # Filtro Box 3×3
    if self._kernel == "box":
      new_image = np.zeros((self._width - 2, self._height - 2))
      for x in range(1, self._width-1):
        for y in range(1, self._height-1):
          average = ((self._image[x-1][y-1] + self._image[x+1][y+1] + self._image[x][y]
                    + self._image[x-1][y]   + self._image[x+1][y]
                    + self._image[x][y-1]   + self._image[x][y+1]
                    + self._image[x-1][y+1] + self._image[x+1][y-1]) / 9)
          new_image[x-1][y-1] = average
      self._image = new_image
      self._width -= 2
      self._height -= 2

    # Filtro Sobel 3×3
    elif self._kernel == "sobel":
      new_image = np.zeros((self._width - 2, self._height - 2))
      for x in range(1, self._width-1):
        for y in range(1, self._height-1):
          sobel_x = ((  self._image[x-1][y-1] -   self._image[x+1][y+1]
                     +2*self._image[x-1][y]   - 2*self._image[x+1][y]
                     +  self._image[x-1][y+1] -   self._image[x+1][y-1]) / 8)
          
          sobel_y = ((-self._image[x-1][y-1] - 2*self._image[x][y-1] - self._image[x+1][y-1]
                      +self._image[x-1][y+1] + 2*self._image[x][y+1] + self._image[x+1][y+1]) / 8)
          new_image[x-1][y-1] = np.sqrt(sobel_x**2 + sobel_y**2)
      self._image = new_image
      self._width -= 2
      self._height -= 2

    # Filtro Laplace 3×3
    elif self._kernel == "laplace":
      new_image = np.zeros((self._width - 2, self._height - 2))
      for x in range(1, self._width-1):
        for y in range(1, self._height-1):
          laplace = ((                    -   self._image[x][y-1]
                    - self._image[x-1][y] + 4*self._image[x][y]  - self._image[x+1][y]
                                          -   self._image[x][y+1]) / 4)
          new_image[x-1][y-1] = abs(laplace)
      self._image = new_image
      self._width -= 2
      self._height -= 2
    else:
      print("Filtro não suportado!")

  def apply_xform(self):
    '''
    Method to apply affine transform through inverse mapping
    You may create auxiliary functions/methods if you'd like
    '''
    # Transformações estão invertidas X/Y, então precisamos corrigir
    self._xform = np.transpose(self._xform)
    # Pega uma referência dos 4 pontos extremos da imagem
    top_left = np.array([0, 0, 1])
    top_right = np.array([self._width, 0, 1])
    bottom_left = np.array([0, self._height, 1])
    bottom_right = np.array([self._width, self._height, 1])

    # Aplica a transformação nos extremos
    t_top_left = self._xform @ top_left
    t_top_right = self._xform @ top_right
    t_bottom_left = self._xform @ bottom_left
    t_bottom_right = self._xform @ bottom_right

    # Calcula os pontos de mínimo e máximo da imagem pós-transformação
    min_x = int(min(t_top_left[0], t_top_right[0], t_bottom_left[0], t_bottom_right[0]))
    max_x = int(max(t_top_left[0], t_top_right[0], t_bottom_left[0], t_bottom_right[0]))
    min_y = int(min(t_top_left[1], t_top_right[1], t_bottom_left[1], t_bottom_right[1]))
    max_y = int(max(t_top_left[1], t_top_right[1], t_bottom_left[1], t_bottom_right[1]))

    # Calcula o tamanho total da imagem pós-transformação
    full_width = int(np.ceil(max_x - min_x))
    full_height = int(np.ceil(max_y - min_y))

    # Cria um array vazio para representar a imagem final
    ximg = np.zeros((full_width, full_height))
    # Calcula a matriz de transformação inversa
    inverse = np.linalg.inv(self._xform)
    out_x = -1
    out_y = -1
    for x in range(min_x, max_x):
      out_x += 1
      out_y = -1
      for y in range(min_y, max_y):
        out_y += 1
        # Calcula a transformação inversa para o ponto (x,y), que nos dá o ponto
        # correspondente na imagem original (aqui designado "left point")
        left_point = inverse @ np.array([x, y, 1])
        left_x = left_point[0]
        left_y = left_point[1]
        
        # Precisamos pegar os pixels originais mais próximos do ponto; para
        # isso, precisamos analisar 4 casos dependendo da posição do ponto
        lo = []
        hi = []
        for i in (left_x, left_y):
          # Caso 1: coordenada é exatamente um valor inteiro
          if np.floor(i) == np.ceil(i):
            lo.append(i - 0.5)
            hi.append(i + 0.5)
          # Caso 2: casas decimais da coordenada são exatamente .5
          elif np.floor(i-0.5) == np.ceil(i-0.5):
            lo.append(i)
            hi.append(i)
          # Caso 3: casas decimais da coordenada são < .5
          elif i < np.floor(i) + .5:
            lo.append(np.floor(i) - .5)
            hi.append(np.floor(i) + .5)
          # Caso 4: casas decimais da coordenada são > .5
          else:
            lo.append(np.ceil(i) - .5)
            hi.append(np.ceil(i) + .5)
        # Temos agora as coordenadas para calcular os 4 pixels mais próximos do
        # ponto invertido
        lo_x = lo[0]
        hi_x = hi[0]
        lo_y = lo[1]
        hi_y = hi[1]

        # Se o ponto está fora da imagem original, preenchemos ele de branco
        if int(lo_y) >= self._height or int(hi_y) >= self._height \
        or int(lo_x) >= self._width or int(hi_x) >= self._width \
        or int(lo_y) < 0 or int(hi_y) < 0 \
        or int(lo_x) < 0 or int(hi_x) < 0:

          ximg[out_x][out_y] = 255

        # Se o ponto está dentro da imagem original, calcula bilinear dos 4
        # pixels calculados anteriormente
        else:
          dist_top_left =     abs(left_x - lo_x) * abs(left_y - lo_y)
          dist_bottom_left =  abs(left_x - lo_x) * abs(left_y - hi_y)
          dist_top_right =    abs(left_x - hi_x) * abs(left_y - lo_y)
          dist_bottom_right = abs(left_x - hi_x) * abs(left_y - hi_y)
        
          bilinear = dist_top_left     * self._image[int(hi_x)][int(hi_y)] \
                   + dist_bottom_left  * self._image[int(lo_x)][int(hi_y)] \
                   + dist_top_right    * self._image[int(hi_x)][int(lo_y)] \
                   + dist_bottom_right * self._image[int(lo_x)][int(lo_y)]

          ximg[out_x][out_y] = bilinear
    
    # Troca a imagem anterior pela imagem pós-transformação
    self._image = ximg
    self._width = full_width
    self._height = full_height

  def show_image(self):
    cv2_imshow(self._image)

  def update(self, show_results = True):
    ''' Method to process image and present results    
    '''
    if (self._kernel is not None):
      self.apply_kernel(self._bhandler)

    if (self._xform is not None):
      # Transforma em array *depois* de saber que não é None ;)
      self._xform = np.array(self._xform)
      self.apply_xform()
    
    if (show_results):
      self.show_image()

"""# ImageProcesser (creation and execution)

### Initialization
"""

imgprocesser = ImageProcesser(graphicx_data, graphicx_mod)

"""### Original image"""

imgprocesser.show_image()

"""### Transformed image"""

imgprocesser.update()