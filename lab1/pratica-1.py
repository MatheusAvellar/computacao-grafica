# -*- coding: utf-8 -*-
"""Prática 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V6o1m3VpeVEdvThq7Xvo2jqqVoceL6xZ

# Prática 1

Pela dupla maravilhosa:

1.   **Matheus Avellar de Barros** (DRE 117038497)
2.   **Pedro Novaes Possato** (DRE 117053803)

Foi implementado no trabalho tanto a triangulação de círculos, quanto a técnica de winding number para detectar pontos dentro de polígonos côncavos e convexos.
"""

import numpy as np
import scipy as sp
from google.colab.patches import cv2_imshow
from google.colab import files
from matplotlib import patheffects
import matplotlib.pyplot as plt
import json

"""## JSON upload"""

uploaded = files.upload()
for fn in uploaded.keys():
  f = open(fn, )
  graphic_data = json.load(f)
  print('User uploaded file "{name}" with length {length} bytes'.format(name=fn, length=len(uploaded[fn])))

"""# Code (inside test and Screen class)"""

def edge(x, y, v0, v1):
  """
  Check if point (x,y) is inside or outside an edge (v0→v1) via Juan Pineda's edge function
  The function is:
    E = (P.x − v0.x) · (V1.y − V0.y) − (P.y − V0.y) · (V1.x − V0.x)
  [Ref] scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage
  
  Args:
    x (float): horizontal point position
    y (float): vertical point position
    v0 (float[]): first vector of edge
    v1 (float[]): second vector of edge

  Returns:
    E(P) > 0 if P is "to the right" of the line
    E(P) = 0 if P is on the line
    E(P) < 0 if P is "to the left" of the line
  """
  return (x - v0[0]) * (v1[1] - v0[1]) - (y - v0[1]) * (v1[0] - v0[0])

def inside(x, y, primitive):
  """
  Check if point (x,y) is inside the primitive
  
  Args:
    x (float): horizontal point position
    y (float): vertical point position

  Returns:
    True if (x,y) is inside the primitive, False case contrary
  """
  # Shorthand pra não precisar escrever com [""] o tempo todo
  vertices = []
  if "vertices" in primitive:
    vertices = primitive["vertices"]

  # Se chegamos aqui, é porque o ponto está dentro da bounding box
  # Precisamos agora testar para cada primitiva separadamente; como convertemos
  # círculos para polígonos no pré-processamento, só nos resta triângulos e
  # polígonos para testar
  if primitive["shape"] == "triangle":
    # O triângulo é o caso mais simples: precisamos somente testar se o ponto
    # está dentro de 3 arestas
    # Assumindo que os vértices estão em disposição anti-horária, testamos
    # se E(P) retorna <= 0 – i.e., se o ponto está "à esquerda" de cada aresta
    v0 = vertices[0]
    v1 = vertices[1]
    v2 = vertices[2]

    if edge(x, y, v0, v1) <= 0 \
    and edge(x, y, v1, v2) <= 0 \
    and edge(x, y, v2, v0) <= 0:
      return True
    
    # Caso contrário, o ponto está fora do triângulo
    return False

  elif primitive["shape"] == "polygon":
    # Implementação do teste Winding Number baseada na implementação em C++
    # do algoritmo de Dan Sunday (2001)
    # [Ref] https://web.archive.org/web/20130126163405/http://geomalgorithms.com/a03-_inclusion.html
    wn = 0
    # Itera sobre todas as arestas do polígono
    l = len(vertices)
    for i in range(l):
      # Aresta de v0 a v1
      v0 = vertices[i]
      v1 = vertices[(i+1)%l] # Vale notar que v[n] = v[0]
      # Se v0 está abaixo (ou ao mesmo nível) do ponto que estamos testando
      if v0[1] <= y:
        # Se v1 estiver acima do ponto, houve cruzamento para cima
        if v1[1] > y:
          # Se o ponto estiver "à direita" da linha
          if edge(x, y, v0, v1) > 0:
            # Temos uma "interseção válida" para cima; Winding Number++
            wn = wn + 1
      # Caso contrário, v0 está acima do ponto
      else:
        # Se v1 estiver abaixo do ponto, houve cruzamento para baixo
        if v1[1] <= y:
          # Se o ponto estiver "à esquerda" da linha
          if edge(x, y, v0, v1) < 0:
            # Temos uma "interseção válida" para baixo; Winding Number--
            wn = wn - 1

    # Temos duas opções aqui: podemos usar a regra even–odd, e pintar somente
    # casos em que o winding number é ímpar; ou podemos usar a regra non-zero,
    # e pintar todos os casos em que o winding number ≠ 0
    # Como o costume (ex. SVG, Geogebra, etc) é usar even–odd, o retorno abaixo
    # retorna True se `wn` for ímpar:
    return wn % 2 == 1
    # Porém, a regra non-zero pode ser utilizada comentando o retorno acima, e
    # descomentando o retorno abaixo, que retorna True se `wn` não for 0:
    # return wn != 0

  # Se nada até aqui retornou, então o comportamento padrão é que o ponto não
  # está intercedendo com nenhuma forma
  return False

class Screen:
  """
  Creates a virtual basic screen

  Args:
      gdata (dict): dictionary containing screen size and scene description
  """
  def __init__(self, gdata):
    self._width = gdata.get("width")
    self._height = gdata.get("height")
    self._scene = self.preprocess( gdata.get("scene") )
    self.create_image()

  def preprocess(self, scene):
    """
    Turns circles into polygons;
    Applies affine transformations on shapes, if required;
    Generates bounding box for later use in rasterization.
    
    Args:
      scene (dict): Scene containing the graphic primitives

    Returns:
      scene (dict): Scene containing the graphic primitives with additional info
    """
    preprop_scene = []

    for primitive in scene:
      # Se a primitiva for um círculo, vamos transformá-la em uma aproximação
      # via polígono
      if primitive["shape"] == "circle":
        # Criamos um array de vértices, com o primeiro vértice já presente, o
        # vértice do centro; além disso, deleta o centro da primitiva
        center = primitive.pop("center", [0,0])
        pverts = [center]
        # Deleta o raio da primitiva, mas pega seu valor antes disso
        radius = primitive.pop("radius", 0)
        # Em seguida, criamos vértices na borda do círculo, separando a
        # circunferência em `steps` partes iguais (2π/steps)
        steps = 40
        step_size = 2*np.pi/steps
        for angle in np.arange(0, 2*np.pi+step_size, step_size):
          # Calcula posição X,Y do ponto na circunferência
          delta_x = np.cos(angle) * radius
          delta_y = np.sin(angle) * radius
          # Adiciona o vértice na lista
          pverts.append([center[0] + delta_x, center[1] + delta_y])
        primitive["shape"] = "polygon"
        primitive["vertices"] = pverts

      # Caso haja alguma transformação afim a ser feita, precisamos fazê-la
      # antes de qualquer verificação de posição; caso contrário, estaríamos
      # testando para uma forma diferente da final
      if "xform" in primitive:
        # Caso a primitiva possua vértices (i.e. não é um círculo)
        if "vertices" in primitive:
          # Para cada vértice da primitiva
          verts = primitive["vertices"]
          for i in range(len(verts)):
            # Cria um vetor NumPy com X e Y do vértice, e 1 para Z
            v_ = np.array([verts[i][0], verts[i][1], 1])
            # Cria a matriz M com a transformação afim
            M = np.array(primitive["xform"])
            # Calcula o vértice pós-transformação afim
            v_res = M @ v_
            # Retorna o vértice atualizado para a primitiva
            primitive["vertices"][i] = v_res.tolist()
      
      # Podemos economizar recursos criando em pré-processamento uma bounding
      # box em volta da forma que queremos desenhar
      min_x = np.inf
      min_y = np.inf
      max_x = 0
      max_y = 0
      # Iteramos sobre todos os vértices e pegamos seus máximos e mínimos
      for v in primitive["vertices"]:
        if v[0] < min_x: min_x = v[0]
        if v[0] > max_x: max_x = v[0]
        if v[1] < min_y: min_y = v[1]
        if v[1] > max_y: max_y = v[1]
      # Salvamos os valores na primitiva para uso na rasterização
      primitive["xbounds"] = [min_x, max_x]
      primitive["ybounds"] = [min_y, max_y]

      preprop_scene.append(primitive)

    return preprop_scene

  def create_image(self):
    ''' Creates image with white background 
    
    Returns 
      image (numpy array): White image with R, G, B channels
    '''
    self._image = 255 *  np.ones((self._height, self._width, 3), np.uint8)

  def rasterize(self):
    ''' Rasterize the primitives along the Screen    
    '''
    for primitive in self._scene:
      # Itera sobre todos os pixels dentro da bouding box da primitiva
      # Caso o ponto esteja fora da bounding box, não precisamos testar mais
      # nada; o ponto necessariamente não é pintado
      [min_x, max_x] = primitive["xbounds"]
      [min_y, max_y] = primitive["ybounds"]
      # Precisamos converter os valores para inteiros para testar a bounding box
      [min_x, max_x] = [round(min_x), round(max_x)]
      [min_y, max_y] = [round(min_y), round(max_y)]
      for w in range(min_x, max_x):
        x = w + 0.5
        for h in range(min_y, max_y):
          y = h + 0.5
          # Confere se o centro do pixel está dentro da primitiva
          if ( inside(x, y, primitive) ):
            im_x, im_y = w, self._height - (h + 1)
            self._image[im_y, im_x] = primitive['color'][::-1]

  def show(self, exec_rasterize = False):
    ''' Show the virtual Screen    
    '''
    if (exec_rasterize):
      self.rasterize()
      
    cv2_imshow(self._image)

"""# Virtual Screen

### Initialization
"""

screen = Screen(graphic_data)

"""### Rasterization and raster graphic visualization"""

screen.show(True)